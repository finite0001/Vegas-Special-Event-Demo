<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Submarine Shooter</title>
<style>
/* Basic page styling */
body,html{
  margin:0; padding:0; overflow:hidden;
  background:#003;
  color:white;
  font-family:sans-serif;
}
#gameCanvas{
  background:#001f3f;
  display:block;
}
#ui{
  position:absolute; top:10px; left:10px; z-index:10;
  font-size:14px;
}
#controls{
  position:absolute; bottom:10px; left:10px; right:10px; height:120px; z-index:20;
  pointer-events:none; /* allow canvas to still receive keyboard */
}
#joystick{
  position:absolute; bottom:0; left:0; width:120px; height:120px; background:rgba(255,255,255,0.1);
  border-radius:50%; pointer-events:auto;
}
#fireButton,#icbmButton{
  position:absolute; bottom:20px; width:80px; height:80px; border-radius:50%;
  background:rgba(255,255,255,0.2); color:white; border:2px solid white;
  pointer-events:auto; font-size:16px;
}
#fireButton{ right:110px; }
#icbmButton{ right:20px; }
#gameOverScreen{
  position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7);
  display:flex; justify-content:center; align-items:center; flex-direction:column;
  font-size:24px; z-index:30; color:white; visibility:hidden;
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<div id="ui"></div>
<div id="controls">
  <div id="joystick"></div>
  <button id="fireButton">Fire</button>
  <button id="icbmButton">ICBM</button>
</div>
<div id="gameOverScreen">
  <div id="gameOverText"></div>
  <button onclick="restartGame()">Restart</button>
</div>
<script>
/*============================================================
  Submarine Side-Scrolling Shooter
  Single-file implementation using HTML5 Canvas and JavaScript
  Major Sections:
    - Utility functions and audio
    - Class definitions (Submarine, Enemy, Projectile, PowerUp, Explosion, ICBM)
    - Input handling (keyboard and touch)
    - Game loop with update and draw
    - Spawning logic and difficulty progression
    - Scoring and high score persistence
=============================================================*/
// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = canvas.width;
let height = canvas.height;

// UI elements
const ui = document.getElementById('ui');
const fireButton = document.getElementById('fireButton');
const icbmButton = document.getElementById('icbmButton');
const joystickEl = document.getElementById('joystick');
const gameOverScreen = document.getElementById('gameOverScreen');
const gameOverText = document.getElementById('gameOverText');

// Audio setup using Web Audio API with simple oscillator sounds
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(freq, duration, type='sine', volume=0.1){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  osc.connect(gain); gain.connect(audioCtx.destination);
  gain.gain.value = volume;
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}
function playTorpedoSound(){ playTone(440,0.1,'square'); }
function playExplosionSound(){ playTone(80,0.4,'sawtooth',0.2); }
function playPowerupSound(){ playTone(660,0.2,'triangle'); }
function startMusic(){
  // simple looping bass line
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square'; o.frequency.value = 120;
  g.gain.value = 0.03; o.connect(g); g.connect(audioCtx.destination);
  o.start();
  return o; // caller may stop() on game over
}
let musicOsc = null;

// Utility random helper
function randRange(min,max){ return Math.random()*(max-min)+min; }

// Base classes
class Torpedo{
  constructor(x,y,dmg){
    this.x=x; this.y=y; this.w=20; this.h=4; this.speed=300; this.dmg=dmg;
  }
  update(dt){ this.x += this.speed*dt; }
  draw(){ ctx.fillStyle='yellow'; ctx.fillRect(this.x,this.y,this.w,this.h); }
  getRect(){ return {x:this.x,y:this.y,w:this.w,h:this.h}; }
}

class EnemyProjectile{
  constructor(x,y){
    this.x=x; this.y=y; this.speed=200; this.w=8; this.h=3;
  }
  update(dt){ this.x -= this.speed*dt; }
  draw(){ ctx.fillStyle='red'; ctx.fillRect(this.x,this.y,this.w,this.h); }
  getRect(){ return {x:this.x,y:this.y,w:this.w,h:this.h}; }
}

class Explosion{
  constructor(x,y){ this.x=x; this.y=y; this.radius=5; this.maxRadius=20; }
  update(dt){ this.radius += 100*dt; }
  draw(){ ctx.strokeStyle='orange'; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.stroke(); }
  done(){ return this.radius>this.maxRadius; }
}

class Enemy{
  constructor(type, x, y, speed, hp){
    this.type=type; this.x=x; this.y=y; this.speed=speed; this.hp=hp;
    this.w=40; this.h=20; this.fireCooldown=randRange(1,3); this.offset=Math.random()*Math.PI*2;
  }
  update(dt){
    this.x -= this.speed*dt;
    if(this.type==='squid'){ this.y += Math.sin(Date.now()/500 + this.offset)*30*dt; }
    if(this.type==='fish'){ this.y += Math.cos(Date.now()/700 + this.offset)*20*dt; }
    this.fireCooldown -= dt;
    if(this.fireCooldown<=0){ this.fireCooldown=randRange(1,3); enemyProjectiles.push(new EnemyProjectile(this.x,this.y+this.h/2)); }
  }
  draw(){
    ctx.fillStyle = this.type==='squid' ? 'purple' : 'green';
    ctx.fillRect(this.x,this.y,this.w,this.h);
  }
  getRect(){ return {x:this.x,y:this.y,w:this.w,h:this.h}; }
}

class PowerUp{
  constructor(type,x,y){ this.type=type; this.x=x; this.y=y; this.w=20; this.h=20; this.speed=100; }
  update(dt){ this.x -= this.speed*dt; }
  draw(){
    if(this.type==='upgrade') ctx.fillStyle='gold';
    else if(this.type==='shield') ctx.fillStyle='cyan';
    else ctx.fillStyle='pink';
    ctx.fillRect(this.x,this.y,this.w,this.h);
  }
  getRect(){ return {x:this.x,y:this.y,w:this.w,h:this.h}; }
  apply(player){
    if(this.type==='upgrade'){ player.damage++; player.fireRate=Math.max(0.1,player.fireRate-0.05); }
    if(this.type==='shield'){ player.shield = 5; }
    if(this.type==='health'){ player.hp = Math.min(player.maxHp, player.hp+20); }
  }
}

class ICBM{
  constructor(target){
    this.startX = player.x; this.startY = 0; // surface
    this.target = target; this.t = 0; this.duration = 1.0;
  }
  update(dt){ this.t += dt; if(this.t>=this.duration){ this.hit(); } }
  hit(){ explosions.push(new Explosion(this.target.x+this.target.w/2, this.target.y+this.target.h/2));
    playExplosionSound(); score += 50; this.target.hp=0; this.done=true; }
  draw(){
    // quadratic bezier path from surface to target
    const t = this.t/this.duration;
    const sx=this.startX, sy=this.startY, tx=this.target.x, ty=this.target.y;
    const cx=(sx+tx)/2; const cy=-80; // control point above surface for arc
    const x=(1-t)*(1-t)*sx + 2*(1-t)*t*cx + t*t*tx;
    const y=(1-t)*(1-t)*sy + 2*(1-t)*t*cy + t*t*ty;
    ctx.strokeStyle='white'; ctx.beginPath(); ctx.moveTo(sx,sy);
    ctx.quadraticCurveTo(cx,cy,tx,ty); ctx.stroke();
    ctx.fillStyle='orange'; ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill();
  }
}

class Submarine{
  constructor(){
    this.x=100; this.y=height/2; this.w=60; this.h=30;
    this.vx=0; this.vy=0; this.speed=200; this.hp=100; this.maxHp=100;
    this.fireRate=0.3; this.fireTimer=0; this.damage=1; this.shield=0;
    this.icbmCooldown=0; this.icbmDelay=10; // seconds
  }
  update(dt){
    this.x += this.vx*dt; this.y += this.vy*dt;
    this.x = Math.max(0, Math.min(width-this.w, this.x));
    this.y = Math.max(0, Math.min(height-this.h, this.y));
    this.fireTimer -= dt; this.icbmCooldown -= dt; if(this.shield>0) this.shield -= dt;
  }
  draw(){
    ctx.fillStyle='navy'; ctx.fillRect(this.x,this.y,this.w,this.h);
    // tower
    ctx.fillStyle='blue'; ctx.fillRect(this.x+10,this.y-10,20,10);
    if(this.shield>0){ ctx.strokeStyle='cyan'; ctx.beginPath(); ctx.arc(this.x+this.w/2,this.y+this.h/2,this.w,0,Math.PI*2); ctx.stroke(); }
  }
  shoot(){
    if(this.fireTimer<=0){ torpedoes.push(new Torpedo(this.x+this.w,this.y+this.h/2,this.damage)); this.fireTimer=this.fireRate; playTorpedoSound(); }
  }
  icbm(){
    if(this.icbmCooldown<=0 && this.y<=10){
      enemies.forEach(e=> icbms.push(new ICBM(e)));
      this.icbmCooldown = this.icbmDelay; playExplosionSound();
    }
  }
  getRect(){ return {x:this.x,y:this.y,w:this.w,h:this.h}; }
}

// Game variables
let player = new Submarine();
let torpedoes=[]; let enemies=[]; let enemyProjectiles=[]; let powerups=[]; let explosions=[]; let icbms=[];
let spawnTimer=0; let powerTimer=0; let difficulty=1; let levelTime=0; let level=1; let damageThisLevel=0;
let score=0; let highScore = parseInt(localStorage.getItem('submarineHighScore')||'0');
let gameOver=false;

// Input handling
let keys={};
window.addEventListener('keydown',e=>{ keys[e.key]=true; if(e.key===' ') player.shoot(); if(e.key==='Shift') player.icbm(); });
window.addEventListener('keyup',e=>{ keys[e.key]=false; });

fireButton.addEventListener('touchstart',e=>{ e.preventDefault(); player.shoot(); });
fireButton.addEventListener('mousedown',e=>{ player.shoot(); });
icbmButton.addEventListener('touchstart',e=>{ e.preventDefault(); player.icbm(); });
icbmButton.addEventListener('mousedown',e=>{ player.icbm(); });

// Joystick logic
const joystick = {active:false,startX:0,startY:0,dx:0,dy:0};
joystickEl.addEventListener('touchstart',e=>{e.preventDefault(); const t=e.touches[0]; joystick.active=true; joystick.startX=t.clientX; joystick.startY=t.clientY;});
joystickEl.addEventListener('touchmove',e=>{e.preventDefault(); const t=e.touches[0]; joystick.dx=t.clientX-joystick.startX; joystick.dy=t.clientY-joystick.startY;});
joystickEl.addEventListener('touchend',e=>{joystick.active=false; joystick.dx=0; joystick.dy=0;});

// Parallax background data
let bg1=0,bg2=0,bg3=0; // offsets for layers

function update(dt){
  if(gameOver) return;
  // background offsets
  bg1 = (bg1 + 20*dt)%width; // surface
  bg2 = (bg2 + 40*dt)%width; // mid
  bg3 = (bg3 + 80*dt)%width; // floor

  // Player movement
  if(keys['ArrowUp']||keys['w']) player.vy=-player.speed;
  else if(keys['ArrowDown']||keys['s']) player.vy=player.speed;
  else player.vy=0;
  if(keys['ArrowLeft']||keys['a']) player.vx=-player.speed;
  else if(keys['ArrowRight']||keys['d']) player.vx=player.speed;
  else player.vx=0;
  if(joystick.active){ player.vx = joystick.dx; player.vy = joystick.dy; }

  player.update(dt);

  // Spawn enemies
  spawnTimer -= dt;
  if(spawnTimer<=0){
    const type = Math.random()<0.5?'squid':'fish';
    const speed = randRange(50,100) + difficulty*10;
    const hp = 2 + Math.floor(difficulty/5);
    enemies.push(new Enemy(type,width,randRange(50,height-50),speed,hp));
    spawnTimer = randRange(1,2)/(difficulty/5+1);
  }
  // Spawn power-ups occasionally
  powerTimer -= dt;
  if(powerTimer<=0){
    const types=['upgrade','shield','health'];
    const t=types[Math.floor(Math.random()*types.length)];
    powerups.push(new PowerUp(t,width,randRange(40,height-40)));
    powerTimer = randRange(8,15);
  }

  // Update arrays
  torpedoes.forEach(p=>p.update(dt));
  enemies.forEach(e=>e.update(dt));
  enemyProjectiles.forEach(p=>p.update(dt));
  powerups.forEach(p=>p.update(dt));
  explosions.forEach(e=>e.update(dt));
  icbms.forEach(i=>i.update(dt));

  // Collision detection
  enemies.forEach((e,ei)=>{
    torpedoes.forEach((t,ti)=>{
      if(rectIntersect(t.getRect(), e.getRect())){ e.hp-=t.dmg; torpedoes.splice(ti,1); }
    });
    if(rectIntersect(e.getRect(), player.getRect())){ damagePlayer(20); e.hp=0; }
    if(e.hp<=0){ explosions.push(new Explosion(e.x+e.w/2,e.y+e.h/2)); score+=100; enemies.splice(ei,1); playExplosionSound(); }
  });
  enemyProjectiles.forEach((p,pi)=>{
    if(rectIntersect(p.getRect(),player.getRect())){ damagePlayer(10); enemyProjectiles.splice(pi,1); }
  });
  powerups.forEach((p,pi)=>{
    if(rectIntersect(p.getRect(),player.getRect())){ p.apply(player); powerups.splice(pi,1); playPowerupSound(); }
  });
  explosions = explosions.filter(e=>!e.done());
  torpedoes = torpedoes.filter(t=>t.x<width);
  enemyProjectiles = enemyProjectiles.filter(p=>p.x+ p.w>0);
  powerups = powerups.filter(p=>p.x+p.w>0);
  icbms = icbms.filter(i=>!i.done);

  // Difficulty progression
  difficulty += dt*0.1; levelTime+=dt;
  if(levelTime>30){ // new level every 30 sec
    if(damageThisLevel===0) score += 500; // bonus
    level++; levelTime=0; damageThisLevel=0;
  }

  // Check game over
  if(player.hp<=0){ endGame(); }

  // UI update
  ui.textContent = `HP: ${Math.floor(player.hp)} Score: ${score} High: ${highScore} Level: ${level} ICBM: ${player.icbmCooldown>0?player.icbmCooldown.toFixed(1)+'s':'Ready'}`;
}

function damagePlayer(amount){
  if(player.shield>0) return; // shield absorbs
  player.hp -= amount; damageThisLevel+=amount;
}

function rectIntersect(a,b){
  return a.x<b.x+b.w && a.x+a.w> b.x && a.y<b.y+b.h && a.y+a.h>b.y;
}

function draw(){
  ctx.clearRect(0,0,width,height);
  // draw background layers
  drawBackground();
  powerups.forEach(p=>p.draw());
  enemies.forEach(e=>e.draw());
  enemyProjectiles.forEach(p=>p.draw());
  torpedoes.forEach(p=>p.draw());
  icbms.forEach(i=>i.draw());
  explosions.forEach(e=>e.draw());
  player.draw();
}

function drawBackground(){
  // surface layer
  ctx.fillStyle='#004'; ctx.fillRect(0,0,width,height);
  ctx.fillStyle='#005';
  for(let i=0;i<width;i+=40){ ctx.fillRect((i+bg1)%width,0,40,10); }
  // mid layer bubbles
  ctx.fillStyle='#002f5f';
  for(let i=0;i<width;i+=60){ ctx.fillRect((i+bg2)%width,200,40,20); }
  // sea floor
  ctx.fillStyle='#013';
  ctx.fillRect(0,height-40,width,40);
  ctx.fillStyle='#024';
  for(let i=0;i<width;i+=40){ ctx.fillRect((i+bg3)%width,height-40,40,40); }
}

// Game loop
let last=0;
function loop(ts){
  const dt = (ts-last)/1000; last=ts;
  update(dt); draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function endGame(){
  gameOver=true; gameOverText.textContent=`Game Over - Score: ${score}`; gameOverScreen.style.visibility='visible';
  if(score>highScore){ highScore=score; localStorage.setItem('submarineHighScore',highScore); }
  if(musicOsc) musicOsc.stop();
}
function restartGame(){
  player = new Submarine(); torpedoes=[]; enemies=[]; enemyProjectiles=[]; powerups=[]; explosions=[]; icbms=[];
  spawnTimer=0; powerTimer=5; difficulty=1; levelTime=0; level=1; damageThisLevel=0; score=0; gameOver=false;
  gameOverScreen.style.visibility='hidden'; musicOsc=startMusic();
}

// start music on first interaction
document.body.addEventListener('click',()=>{ if(!musicOsc){ musicOsc=startMusic(); }});
document.body.addEventListener('touchstart',()=>{ if(!musicOsc){ musicOsc=startMusic(); }});

// Helper to restart on load
restartGame();

</script>
</body>
</html>
